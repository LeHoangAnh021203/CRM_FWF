import { AuthAPI } from './auth-api'

export class TokenService {
  // Debug function ƒë·ªÉ ki·ªÉm tra token expiration
  static debugTokenExpiration(token: string): void {
    try {
      const payload = AuthAPI.decodeToken(token)
      if (!payload) {
        console.log('‚ùå Token invalid or cannot be decoded')
        return
      }
      
      const expirationTime = payload.exp * 1000
      const currentTime = Date.now()
      const timeUntilExpiry = expirationTime - currentTime
      const minutesUntilExpiry = Math.floor(timeUntilExpiry / (1000 * 60))
      
      console.log('üîç Token Debug Info:')
      console.log('  - Issued at:', new Date(payload.iat * 1000).toLocaleString())
      console.log('  - Expires at:', new Date(expirationTime).toLocaleString())
      console.log('  - Current time:', new Date(currentTime).toLocaleString())
      console.log('  - Time until expiry:', minutesUntilExpiry, 'minutes')
      console.log('  - Is expired:', timeUntilExpiry <= 0)
      console.log('  - Should refresh:', this.isTokenExpired(token))
    } catch (error) {
      console.error('Error debugging token:', error)
    }
  }

  // Ki·ªÉm tra token c√≥ h·∫øt h·∫°n kh√¥ng
  static isTokenExpired(token: string): boolean {
    try {
      const payload = AuthAPI.decodeToken(token)
      if (!payload) return true
      
      // JWT exp l√† timestamp (seconds), convert to milliseconds
      const expirationTime = payload.exp * 1000
      const currentTime = Date.now()
      
      // Refresh token 5 ph√∫t tr∆∞·ªõc khi h·∫øt h·∫°n
      const refreshThreshold = 5 * 60 * 1000 // 5 minutes
      
      return currentTime >= (expirationTime - refreshThreshold)
    } catch (error) {
      console.error('Error checking token expiration:', error)
      return true
    }
  }

  // L·∫•y access token, t·ª± ƒë·ªông refresh n·∫øu c·∫ßn
  static async getValidAccessToken(): Promise<string | null> {
    const accessToken = localStorage.getItem('access_token')
    const refreshToken = localStorage.getItem('refresh_token')
    
    if (!accessToken || !refreshToken) {
      return null
    }

    // Debug token expiration
    this.debugTokenExpiration(accessToken)

    // Ki·ªÉm tra xem token c√≥ h·∫øt h·∫°n kh√¥ng
    if (this.isTokenExpired(accessToken)) {
      console.log('Access token expired, refreshing...')
      try {
        const newToken = await this.refreshAccessToken(refreshToken)
        return newToken
      } catch (error) {
        console.error('Failed to refresh token:', error)
        // Token refresh failed, user needs to login again
        this.clearTokens()
        return null
      }
    }

    return accessToken
  }

  // Refresh access token
  static async refreshAccessToken(refreshToken: string): Promise<string> {
    try {
      const response = await AuthAPI.refreshToken(refreshToken)
      const newAccessToken = response.access_token
      
      // L∆∞u token m·ªõi
      localStorage.setItem('access_token', newAccessToken)
      
      // Also update cookie
      document.cookie = `token=${newAccessToken}; path=/; max-age=${7 * 24 * 60 * 60}; SameSite=Strict`
      
      console.log('Token refreshed successfully')
      return newAccessToken
    } catch (error) {
      console.error('Token refresh failed:', error)
      throw error
    }
  }

  // X√≥a t·∫•t c·∫£ tokens
  static clearTokens(): void {
    localStorage.removeItem('access_token')
    localStorage.removeItem('refresh_token')
    localStorage.removeItem('user_data')
    // Clear cookie
    document.cookie = 'token=; path=/; expires=Thu, 01 Jan 1970 00:00:00 GMT'
  }

  // Ki·ªÉm tra user c√≥ ƒëƒÉng nh·∫≠p kh√¥ng
  static isAuthenticated(): boolean {
    const accessToken = localStorage.getItem('access_token')
    const refreshToken = localStorage.getItem('refresh_token')
    return !!(accessToken && refreshToken)
  }
}
