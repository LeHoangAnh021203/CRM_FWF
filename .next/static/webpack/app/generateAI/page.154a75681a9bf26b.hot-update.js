"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/generateAI/page",{

/***/ "(app-pages-browser)/./src/lib/ai-service.ts":
/*!*******************************!*\
  !*** ./src/lib/ai-service.ts ***!
  \*******************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   aiService: () => (/* binding */ aiService)\n/* harmony export */ });\n/* provided dependency */ var process = __webpack_require__(/*! process */ \"(app-pages-browser)/./node_modules/next/dist/build/polyfills/process.js\");\n// AI Service - Automatic Configuration\nclass AIService {\n    loadConfig() {\n        // Load from environment variables automatically\n        const stabilityKey = \"sk-EbyLFvWn0wKLaQ2WjszoOB6uEhYsfdOHHgCHqxMTjKjHzbsp\";\n        const replicateKey = process.env.NEXT_PUBLIC_REPLICATE_API_KEY;\n        const openaiKey = process.env.NEXT_PUBLIC_OPENAI_API_KEY;\n        // Priority: Stability AI > Replicate > OpenAI > Demo\n        if (stabilityKey) {\n            return {\n                service: 'stability',\n                apiKey: stabilityKey,\n                endpoint: 'https://api.stability.ai/v1/generation/stable-diffusion-xl-1024-v1-0/image-to-image',\n                isConfigured: true\n            };\n        } else if (replicateKey) {\n            return {\n                service: 'replicate',\n                apiKey: replicateKey,\n                endpoint: 'https://api.replicate.com/v1/predictions',\n                isConfigured: true\n            };\n        } else if (openaiKey) {\n            return {\n                service: 'openai',\n                apiKey: openaiKey,\n                endpoint: 'https://api.openai.com/v1/images/generations',\n                isConfigured: true\n            };\n        }\n        // Fallback to demo mode\n        return {\n            service: 'demo',\n            apiKey: '',\n            endpoint: '',\n            isConfigured: false\n        };\n    }\n    async generateFoxPerson(imageBlob, prompt, strength) {\n        try {\n            if (!this.config.isConfigured) {\n                throw new Error('No AI service configured');\n            }\n            console.log(\"Using \".concat(this.config.service, \" service\"));\n            switch(this.config.service){\n                case 'stability':\n                    return await this.generateWithStability(imageBlob, prompt, strength);\n                case 'replicate':\n                    return await this.generateWithReplicate(imageBlob, prompt, strength);\n                case 'openai':\n                    return await this.generateWithOpenAI(imageBlob, prompt, strength);\n                default:\n                    throw new Error('Unsupported service');\n            }\n        } catch (error) {\n            console.error('AI generation error:', error);\n            throw error;\n        }\n    }\n    async generateWithStability(imageBlob, prompt, strength) {\n        const formData = new FormData();\n        formData.append('init_image', imageBlob, 'input.jpg');\n        // Include strength in the prompt text\n        const strengthText = strength >= 0.8 ? \"high transformation\" : strength >= 0.5 ? \"medium transformation\" : \"subtle transformation\";\n        const enhancedPrompt = \"Transform this person into a beautiful fox person with \".concat(strengthText, \": \").concat(prompt, \", anthropomorphic fox, detailed orange fur, pointy fox ears, bushy fox tail, human-like body, high quality, detailed, professional photography\");\n        formData.append('text_prompts[0][text]', enhancedPrompt);\n        formData.append('text_prompts[0][weight]', '1');\n        formData.append('text_prompts[1][text]', 'low quality, blurry, distorted, bad anatomy, deformed, ugly, bad proportions');\n        formData.append('text_prompts[1][weight]', '-1');\n        formData.append('cfg_scale', '7.5');\n        formData.append('steps', '30');\n        formData.append('samples', '1');\n        formData.append('style_preset', 'photographic');\n        const response = await fetch(this.config.endpoint, {\n            method: 'POST',\n            headers: {\n                'Authorization': \"Bearer \".concat(this.config.apiKey),\n                'Accept': 'application/json'\n            },\n            body: formData\n        });\n        if (!response.ok) {\n            const errorText = await response.text();\n            throw new Error(\"Stability AI failed: \".concat(response.status, \" - \").concat(errorText));\n        }\n        const result = await response.json();\n        if (result.artifacts && result.artifacts.length > 0) {\n            return \"data:image/png;base64,\".concat(result.artifacts[0].base64);\n        } else {\n            throw new Error('No image generated');\n        }\n    }\n    async generateWithReplicate(imageBlob, prompt, strength) {\n        // Convert blob to base64\n        const base64 = await this.blobToBase64(imageBlob);\n        const response = await fetch(this.config.endpoint, {\n            method: 'POST',\n            headers: {\n                'Authorization': \"Token \".concat(this.config.apiKey),\n                'Content-Type': 'application/json'\n            },\n            body: JSON.stringify({\n                version: \"39ed52f2a78e934b3ba6e2a89f5b1c712de7dfea535525255b1aa35c5565e08b\",\n                input: {\n                    image: base64,\n                    prompt: \"fox person: \".concat(prompt),\n                    strength: strength\n                }\n            })\n        });\n        if (!response.ok) {\n            throw new Error(\"Replicate failed: \".concat(response.status));\n        }\n        const result = await response.json();\n        return result.output[0]; // Replicate returns image URLs\n    }\n    async generateWithOpenAI(imageBlob, prompt, strength) {\n        const response = await fetch(this.config.endpoint, {\n            method: 'POST',\n            headers: {\n                'Authorization': \"Bearer \".concat(this.config.apiKey),\n                'Content-Type': 'application/json'\n            },\n            body: JSON.stringify({\n                model: \"dall-e-3\",\n                prompt: \"Transform this person into a fox person with strength \".concat(strength, \": \").concat(prompt),\n                n: 1,\n                size: \"1024x1024\"\n            })\n        });\n        if (!response.ok) {\n            throw new Error(\"OpenAI failed: \".concat(response.status));\n        }\n        const result = await response.json();\n        return result.data[0].url; // OpenAI returns image URLs\n    }\n    blobToBase64(blob) {\n        return new Promise((resolve, reject)=>{\n            const reader = new FileReader();\n            reader.onload = ()=>{\n                const result = reader.result;\n                resolve(result.split(',')[1]); // Remove data:image/...;base64, prefix\n            };\n            reader.onerror = reject;\n            reader.readAsDataURL(blob);\n        });\n    }\n    isConfigured() {\n        return this.config.isConfigured;\n    }\n    getServiceName() {\n        return this.config.service;\n    }\n    constructor(){\n        this.config = this.loadConfig();\n    }\n}\n// Export singleton instance\nconst aiService = new AIService();\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9saWIvYWktc2VydmljZS50cyIsIm1hcHBpbmdzIjoiOzs7OztBQUFBLHVDQUF1QztBQVF2QyxNQUFNQTtJQU9JQyxhQUE4QjtRQUNwQyxnREFBZ0Q7UUFDaEQsTUFBTUMsZUFBZUMscURBQXlDO1FBQzlELE1BQU1HLGVBQWVILE9BQU9BLENBQUNDLEdBQUcsQ0FBQ0csNkJBQTZCO1FBQzlELE1BQU1DLFlBQVlMLE9BQU9BLENBQUNDLEdBQUcsQ0FBQ0ssMEJBQTBCO1FBRXhELHFEQUFxRDtRQUNyRCxJQUFJUCxjQUFjO1lBQ2hCLE9BQU87Z0JBQ0xRLFNBQVM7Z0JBQ1RDLFFBQVFUO2dCQUNSVSxVQUFVO2dCQUNWQyxjQUFjO1lBQ2hCO1FBQ0YsT0FBTyxJQUFJUCxjQUFjO1lBQ3ZCLE9BQU87Z0JBQ0xJLFNBQVM7Z0JBQ1RDLFFBQVFMO2dCQUNSTSxVQUFVO2dCQUNWQyxjQUFjO1lBQ2hCO1FBQ0YsT0FBTyxJQUFJTCxXQUFXO1lBQ3BCLE9BQU87Z0JBQ0xFLFNBQVM7Z0JBQ1RDLFFBQVFIO2dCQUNSSSxVQUFVO2dCQUNWQyxjQUFjO1lBQ2hCO1FBQ0Y7UUFFQSx3QkFBd0I7UUFDeEIsT0FBTztZQUNMSCxTQUFTO1lBQ1RDLFFBQVE7WUFDUkMsVUFBVTtZQUNWQyxjQUFjO1FBQ2hCO0lBQ0Y7SUFFQSxNQUFhQyxrQkFBa0JDLFNBQWUsRUFBRUMsTUFBYyxFQUFFQyxRQUFnQixFQUFtQjtRQUNqRyxJQUFJO1lBQ0YsSUFBSSxDQUFDLElBQUksQ0FBQ0MsTUFBTSxDQUFDTCxZQUFZLEVBQUU7Z0JBQzdCLE1BQU0sSUFBSU0sTUFBTTtZQUNsQjtZQUVBQyxRQUFRQyxHQUFHLENBQUMsU0FBNkIsT0FBcEIsSUFBSSxDQUFDSCxNQUFNLENBQUNSLE9BQU8sRUFBQztZQUV6QyxPQUFRLElBQUksQ0FBQ1EsTUFBTSxDQUFDUixPQUFPO2dCQUN6QixLQUFLO29CQUNILE9BQU8sTUFBTSxJQUFJLENBQUNZLHFCQUFxQixDQUFD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RCxNQUFNLEdBQUcsSUFBSSxDQUFDakIsVUFBVTtJQUMvQjtBQThLRjtBQUVBLDRCQUE0QjtBQUNyQixNQUFNb0UsWUFBWSxJQUFJckUsWUFBWSIsInNvdXJjZXMiOlsiL1VzZXJzL2xlaG9hbmdhbmgvRG9jdW1lbnRzL0ZCIE5ldHdvcmsvRkUvc3JjL2xpYi9haS1zZXJ2aWNlLnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIEFJIFNlcnZpY2UgLSBBdXRvbWF0aWMgQ29uZmlndXJhdGlvblxuZXhwb3J0IGludGVyZmFjZSBBSVNlcnZpY2VDb25maWcge1xuICBzZXJ2aWNlOiAnc3RhYmlsaXR5JyB8ICdyZXBsaWNhdGUnIHwgJ29wZW5haScgfCAnZGVtbyc7XG4gIGFwaUtleTogc3RyaW5nO1xuICBlbmRwb2ludDogc3RyaW5nO1xuICBpc0NvbmZpZ3VyZWQ6IGJvb2xlYW47XG59XG5cbmNsYXNzIEFJU2VydmljZSB7XG4gIHByaXZhdGUgY29uZmlnOiBBSVNlcnZpY2VDb25maWc7XG5cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5jb25maWcgPSB0aGlzLmxvYWRDb25maWcoKTtcbiAgfVxuXG4gIHByaXZhdGUgbG9hZENvbmZpZygpOiBBSVNlcnZpY2VDb25maWcge1xuICAgIC8vIExvYWQgZnJvbSBlbnZpcm9ubWVudCB2YXJpYWJsZXMgYXV0b21hdGljYWxseVxuICAgIGNvbnN0IHN0YWJpbGl0eUtleSA9IHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX1NUQUJJTElUWV9BUElfS0VZO1xuICAgIGNvbnN0IHJlcGxpY2F0ZUtleSA9IHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX1JFUExJQ0FURV9BUElfS0VZO1xuICAgIGNvbnN0IG9wZW5haUtleSA9IHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX09QRU5BSV9BUElfS0VZO1xuXG4gICAgLy8gUHJpb3JpdHk6IFN0YWJpbGl0eSBBSSA+IFJlcGxpY2F0ZSA+IE9wZW5BSSA+IERlbW9cbiAgICBpZiAoc3RhYmlsaXR5S2V5KSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBzZXJ2aWNlOiAnc3RhYmlsaXR5JyxcbiAgICAgICAgYXBpS2V5OiBzdGFiaWxpdHlLZXksXG4gICAgICAgIGVuZHBvaW50OiAnaHR0cHM6Ly9hcGkuc3RhYmlsaXR5LmFpL3YxL2dlbmVyYXRpb24vc3RhYmxlLWRpZmZ1c2lvbi14bC0xMDI0LXYxLTAvaW1hZ2UtdG8taW1hZ2UnLFxuICAgICAgICBpc0NvbmZpZ3VyZWQ6IHRydWVcbiAgICAgIH07XG4gICAgfSBlbHNlIGlmIChyZXBsaWNhdGVLZXkpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHNlcnZpY2U6ICdyZXBsaWNhdGUnLFxuICAgICAgICBhcGlLZXk6IHJlcGxpY2F0ZUtleSxcbiAgICAgICAgZW5kcG9pbnQ6ICdodHRwczovL2FwaS5yZXBsaWNhdGUuY29tL3YxL3ByZWRpY3Rpb25zJyxcbiAgICAgICAgaXNDb25maWd1cmVkOiB0cnVlXG4gICAgICB9O1xuICAgIH0gZWxzZSBpZiAob3BlbmFpS2V5KSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBzZXJ2aWNlOiAnb3BlbmFpJyxcbiAgICAgICAgYXBpS2V5OiBvcGVuYWlLZXksXG4gICAgICAgIGVuZHBvaW50OiAnaHR0cHM6Ly9hcGkub3BlbmFpLmNvbS92MS9pbWFnZXMvZ2VuZXJhdGlvbnMnLFxuICAgICAgICBpc0NvbmZpZ3VyZWQ6IHRydWVcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gRmFsbGJhY2sgdG8gZGVtbyBtb2RlXG4gICAgcmV0dXJuIHtcbiAgICAgIHNlcnZpY2U6ICdkZW1vJyxcbiAgICAgIGFwaUtleTogJycsXG4gICAgICBlbmRwb2ludDogJycsXG4gICAgICBpc0NvbmZpZ3VyZWQ6IGZhbHNlXG4gICAgfTtcbiAgfVxuXG4gIHB1YmxpYyBhc3luYyBnZW5lcmF0ZUZveFBlcnNvbihpbWFnZUJsb2I6IEJsb2IsIHByb21wdDogc3RyaW5nLCBzdHJlbmd0aDogbnVtYmVyKTogUHJvbWlzZTxzdHJpbmc+IHtcbiAgICB0cnkge1xuICAgICAgaWYgKCF0aGlzLmNvbmZpZy5pc0NvbmZpZ3VyZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBBSSBzZXJ2aWNlIGNvbmZpZ3VyZWQnKTtcbiAgICAgIH1cblxuICAgICAgY29uc29sZS5sb2coYFVzaW5nICR7dGhpcy5jb25maWcuc2VydmljZX0gc2VydmljZWApO1xuXG4gICAgICBzd2l0Y2ggKHRoaXMuY29uZmlnLnNlcnZpY2UpIHtcbiAgICAgICAgY2FzZSAnc3RhYmlsaXR5JzpcbiAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5nZW5lcmF0ZVdpdGhTdGFiaWxpdHkoaW1hZ2VCbG9iLCBwcm9tcHQsIHN0cmVuZ3RoKTtcbiAgICAgICAgY2FzZSAncmVwbGljYXRlJzpcbiAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5nZW5lcmF0ZVdpdGhSZXBsaWNhdGUoaW1hZ2VCbG9iLCBwcm9tcHQsIHN0cmVuZ3RoKTtcbiAgICAgICAgY2FzZSAnb3BlbmFpJzpcbiAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5nZW5lcmF0ZVdpdGhPcGVuQUkoaW1hZ2VCbG9iLCBwcm9tcHQsIHN0cmVuZ3RoKTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vuc3VwcG9ydGVkIHNlcnZpY2UnKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignQUkgZ2VuZXJhdGlvbiBlcnJvcjonLCBlcnJvcik7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIGFzeW5jIGdlbmVyYXRlV2l0aFN0YWJpbGl0eShpbWFnZUJsb2I6IEJsb2IsIHByb21wdDogc3RyaW5nLCBzdHJlbmd0aDogbnVtYmVyKTogUHJvbWlzZTxzdHJpbmc+IHtcbiAgICBjb25zdCBmb3JtRGF0YSA9IG5ldyBGb3JtRGF0YSgpO1xuICAgIGZvcm1EYXRhLmFwcGVuZCgnaW5pdF9pbWFnZScsIGltYWdlQmxvYiwgJ2lucHV0LmpwZycpO1xuICAgIFxuICAgIC8vIEluY2x1ZGUgc3RyZW5ndGggaW4gdGhlIHByb21wdCB0ZXh0XG4gICAgY29uc3Qgc3RyZW5ndGhUZXh0ID0gc3RyZW5ndGggPj0gMC44ID8gXCJoaWdoIHRyYW5zZm9ybWF0aW9uXCIgOiBzdHJlbmd0aCA+PSAwLjUgPyBcIm1lZGl1bSB0cmFuc2Zvcm1hdGlvblwiIDogXCJzdWJ0bGUgdHJhbnNmb3JtYXRpb25cIjtcbiAgICBjb25zdCBlbmhhbmNlZFByb21wdCA9IGBUcmFuc2Zvcm0gdGhpcyBwZXJzb24gaW50byBhIGJlYXV0aWZ1bCBmb3ggcGVyc29uIHdpdGggJHtzdHJlbmd0aFRleHR9OiAke3Byb21wdH0sIGFudGhyb3BvbW9ycGhpYyBmb3gsIGRldGFpbGVkIG9yYW5nZSBmdXIsIHBvaW50eSBmb3ggZWFycywgYnVzaHkgZm94IHRhaWwsIGh1bWFuLWxpa2UgYm9keSwgaGlnaCBxdWFsaXR5LCBkZXRhaWxlZCwgcHJvZmVzc2lvbmFsIHBob3RvZ3JhcGh5YDtcbiAgICBmb3JtRGF0YS5hcHBlbmQoJ3RleHRfcHJvbXB0c1swXVt0ZXh0XScsIGVuaGFuY2VkUHJvbXB0KTtcbiAgICBmb3JtRGF0YS5hcHBlbmQoJ3RleHRfcHJvbXB0c1swXVt3ZWlnaHRdJywgJzEnKTtcbiAgICBmb3JtRGF0YS5hcHBlbmQoJ3RleHRfcHJvbXB0c1sxXVt0ZXh0XScsICdsb3cgcXVhbGl0eSwgYmx1cnJ5LCBkaXN0b3J0ZWQsIGJhZCBhbmF0b215LCBkZWZvcm1lZCwgdWdseSwgYmFkIHByb3BvcnRpb25zJyk7XG4gICAgZm9ybURhdGEuYXBwZW5kKCd0ZXh0X3Byb21wdHNbMV1bd2VpZ2h0XScsICctMScpO1xuICAgIGZvcm1EYXRhLmFwcGVuZCgnY2ZnX3NjYWxlJywgJzcuNScpO1xuICAgIGZvcm1EYXRhLmFwcGVuZCgnc3RlcHMnLCAnMzAnKTtcbiAgICBmb3JtRGF0YS5hcHBlbmQoJ3NhbXBsZXMnLCAnMScpO1xuICAgIGZvcm1EYXRhLmFwcGVuZCgnc3R5bGVfcHJlc2V0JywgJ3Bob3RvZ3JhcGhpYycpO1xuXG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCh0aGlzLmNvbmZpZy5lbmRwb2ludCwge1xuICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICBoZWFkZXJzOiB7XG4gICAgICAgICdBdXRob3JpemF0aW9uJzogYEJlYXJlciAke3RoaXMuY29uZmlnLmFwaUtleX1gLFxuICAgICAgICAnQWNjZXB0JzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgfSxcbiAgICAgIGJvZHk6IGZvcm1EYXRhLFxuICAgIH0pO1xuXG4gICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgY29uc3QgZXJyb3JUZXh0ID0gYXdhaXQgcmVzcG9uc2UudGV4dCgpO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBTdGFiaWxpdHkgQUkgZmFpbGVkOiAke3Jlc3BvbnNlLnN0YXR1c30gLSAke2Vycm9yVGV4dH1gKTtcbiAgICB9XG5cbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgXG4gICAgaWYgKHJlc3VsdC5hcnRpZmFjdHMgJiYgcmVzdWx0LmFydGlmYWN0cy5sZW5ndGggPiAwKSB7XG4gICAgICByZXR1cm4gYGRhdGE6aW1hZ2UvcG5nO2Jhc2U2NCwke3Jlc3VsdC5hcnRpZmFjdHNbMF0uYmFzZTY0fWA7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignTm8gaW1hZ2UgZ2VuZXJhdGVkJyk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBhc3luYyBnZW5lcmF0ZVdpdGhSZXBsaWNhdGUoaW1hZ2VCbG9iOiBCbG9iLCBwcm9tcHQ6IHN0cmluZywgc3RyZW5ndGg6IG51bWJlcik6IFByb21pc2U8c3RyaW5nPiB7XG4gICAgLy8gQ29udmVydCBibG9iIHRvIGJhc2U2NFxuICAgIGNvbnN0IGJhc2U2NCA9IGF3YWl0IHRoaXMuYmxvYlRvQmFzZTY0KGltYWdlQmxvYik7XG4gICAgXG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCh0aGlzLmNvbmZpZy5lbmRwb2ludCwge1xuICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICBoZWFkZXJzOiB7XG4gICAgICAgICdBdXRob3JpemF0aW9uJzogYFRva2VuICR7dGhpcy5jb25maWcuYXBpS2V5fWAsXG4gICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICB9LFxuICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICB2ZXJzaW9uOiBcIjM5ZWQ1MmYyYTc4ZTkzNGIzYmE2ZTJhODlmNWIxYzcxMmRlN2RmZWE1MzU1MjUyNTViMWFhMzVjNTU2NWUwOGJcIixcbiAgICAgICAgaW5wdXQ6IHtcbiAgICAgICAgICBpbWFnZTogYmFzZTY0LFxuICAgICAgICAgIHByb21wdDogYGZveCBwZXJzb246ICR7cHJvbXB0fWAsXG4gICAgICAgICAgc3RyZW5ndGg6IHN0cmVuZ3RoXG4gICAgICAgIH1cbiAgICAgIH0pLFxuICAgIH0pO1xuXG4gICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBSZXBsaWNhdGUgZmFpbGVkOiAke3Jlc3BvbnNlLnN0YXR1c31gKTtcbiAgICB9XG5cbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgcmV0dXJuIHJlc3VsdC5vdXRwdXRbMF07IC8vIFJlcGxpY2F0ZSByZXR1cm5zIGltYWdlIFVSTHNcbiAgfVxuXG4gIHByaXZhdGUgYXN5bmMgZ2VuZXJhdGVXaXRoT3BlbkFJKGltYWdlQmxvYjogQmxvYiwgcHJvbXB0OiBzdHJpbmcsIHN0cmVuZ3RoOiBudW1iZXIpOiBQcm9taXNlPHN0cmluZz4ge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2godGhpcy5jb25maWcuZW5kcG9pbnQsIHtcbiAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgaGVhZGVyczoge1xuICAgICAgICAnQXV0aG9yaXphdGlvbic6IGBCZWFyZXIgJHt0aGlzLmNvbmZpZy5hcGlLZXl9YCxcbiAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgIH0sXG4gICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgIG1vZGVsOiBcImRhbGwtZS0zXCIsXG4gICAgICAgIHByb21wdDogYFRyYW5zZm9ybSB0aGlzIHBlcnNvbiBpbnRvIGEgZm94IHBlcnNvbiB3aXRoIHN0cmVuZ3RoICR7c3RyZW5ndGh9OiAke3Byb21wdH1gLFxuICAgICAgICBuOiAxLFxuICAgICAgICBzaXplOiBcIjEwMjR4MTAyNFwiXG4gICAgICB9KSxcbiAgICB9KTtcblxuICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgT3BlbkFJIGZhaWxlZDogJHtyZXNwb25zZS5zdGF0dXN9YCk7XG4gICAgfVxuXG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgIHJldHVybiByZXN1bHQuZGF0YVswXS51cmw7IC8vIE9wZW5BSSByZXR1cm5zIGltYWdlIFVSTHNcbiAgfVxuXG4gIHByaXZhdGUgYmxvYlRvQmFzZTY0KGJsb2I6IEJsb2IpOiBQcm9taXNlPHN0cmluZz4ge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBjb25zdCByZWFkZXIgPSBuZXcgRmlsZVJlYWRlcigpO1xuICAgICAgcmVhZGVyLm9ubG9hZCA9ICgpID0+IHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gcmVhZGVyLnJlc3VsdCBhcyBzdHJpbmc7XG4gICAgICAgIHJlc29sdmUocmVzdWx0LnNwbGl0KCcsJylbMV0pOyAvLyBSZW1vdmUgZGF0YTppbWFnZS8uLi47YmFzZTY0LCBwcmVmaXhcbiAgICAgIH07XG4gICAgICByZWFkZXIub25lcnJvciA9IHJlamVjdDtcbiAgICAgIHJlYWRlci5yZWFkQXNEYXRhVVJMKGJsb2IpO1xuICAgIH0pO1xuICB9XG5cbiAgcHVibGljIGlzQ29uZmlndXJlZCgpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5jb25maWcuaXNDb25maWd1cmVkO1xuICB9XG5cbiAgcHVibGljIGdldFNlcnZpY2VOYW1lKCk6IHN0cmluZyB7XG4gICAgcmV0dXJuIHRoaXMuY29uZmlnLnNlcnZpY2U7XG4gIH1cbn1cblxuLy8gRXhwb3J0IHNpbmdsZXRvbiBpbnN0YW5jZVxuZXhwb3J0IGNvbnN0IGFpU2VydmljZSA9IG5ldyBBSVNlcnZpY2UoKTtcbiJdLCJuYW1lcyI6WyJBSVNlcnZpY2UiLCJsb2FkQ29uZmlnIiwic3RhYmlsaXR5S2V5IiwicHJvY2VzcyIsImVudiIsIk5FWFRfUFVCTElDX1NUQUJJTElUWV9BUElfS0VZIiwicmVwbGljYXRlS2V5IiwiTkVYVF9QVUJMSUNfUkVQTElDQVRFX0FQSV9LRVkiLCJvcGVuYWlLZXkiLCJORVhUX1BVQkxJQ19PUEVOQUlfQVBJX0tFWSIsInNlcnZpY2UiLCJhcGlLZXkiLCJlbmRwb2ludCIsImlzQ29uZmlndXJlZCIsImdlbmVyYXRlRm94UGVyc29uIiwiaW1hZ2VCbG9iIiwicHJvbXB0Iiwic3RyZW5ndGgiLCJjb25maWciLCJFcnJvciIsImNvbnNvbGUiLCJsb2ciLCJnZW5lcmF0ZVdpdGhTdGFiaWxpdHkiLCJnZW5lcmF0ZVdpdGhSZXBsaWNhdGUiLCJnZW5lcmF0ZVdpdGhPcGVuQUkiLCJlcnJvciIsImZvcm1EYXRhIiwiRm9ybURhdGEiLCJhcHBlbmQiLCJzdHJlbmd0aFRleHQiLCJlbmhhbmNlZFByb21wdCIsInJlc3BvbnNlIiwiZmV0Y2giLCJtZXRob2QiLCJoZWFkZXJzIiwiYm9keSIsIm9rIiwiZXJyb3JUZXh0IiwidGV4dCIsInN0YXR1cyIsInJlc3VsdCIsImpzb24iLCJhcnRpZmFjdHMiLCJsZW5ndGgiLCJiYXNlNjQiLCJibG9iVG9CYXNlNjQiLCJKU09OIiwic3RyaW5naWZ5IiwidmVyc2lvbiIsImlucHV0IiwiaW1hZ2UiLCJvdXRwdXQiLCJtb2RlbCIsIm4iLCJzaXplIiwiZGF0YSIsInVybCIsImJsb2IiLCJQcm9taXNlIiwicmVzb2x2ZSIsInJlamVjdCIsInJlYWRlciIsIkZpbGVSZWFkZXIiLCJvbmxvYWQiLCJzcGxpdCIsIm9uZXJyb3IiLCJyZWFkQXNEYXRhVVJMIiwiZ2V0U2VydmljZU5hbWUiLCJjb25zdHJ1Y3RvciIsImFpU2VydmljZSJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/lib/ai-service.ts\n"));

/***/ })

});