"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/generateAI/page",{

/***/ "(app-pages-browser)/./src/lib/ai-service.ts":
/*!*******************************!*\
  !*** ./src/lib/ai-service.ts ***!
  \*******************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   aiService: () => (/* binding */ aiService)\n/* harmony export */ });\n/* provided dependency */ var process = __webpack_require__(/*! process */ \"(app-pages-browser)/./node_modules/next/dist/build/polyfills/process.js\");\n// AI Service - Automatic Configuration with Fallback\nclass AIService {\n    loadConfig() {\n        // Load from environment variables automatically\n        const stabilityKey = \"sk-CHoGTOr0amzOFTw5kFQh0tIDVl5gsrEoJeuu3ENbXr7tnDJM\";\n        const replicateKey = \"r8_H4zWx5r0UAQg6iJmKgNiVbWCa0wNw083qIba4\";\n        const openaiKey = \"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\";\n        // Priority: Stability AI > Replicate > OpenAI > Demo\n        if (stabilityKey) {\n            return {\n                service: 'stability',\n                apiKey: stabilityKey,\n                endpoint: 'https://api.stability.ai/v1/generation/stable-diffusion-xl-1024-v1-0/image-to-image',\n                isConfigured: true\n            };\n        } else if (replicateKey) {\n            return {\n                service: 'replicate',\n                apiKey: replicateKey,\n                endpoint: 'https://api.replicate.com/v1/predictions',\n                isConfigured: true\n            };\n        } else if (openaiKey) {\n            return {\n                service: 'openai',\n                apiKey: openaiKey,\n                endpoint: 'https://api.openai.com/v1/images/generations',\n                isConfigured: true\n            };\n        }\n        // Fallback to demo mode\n        return {\n            service: 'demo',\n            apiKey: '',\n            endpoint: '',\n            isConfigured: false\n        };\n    }\n    getServiceConfig(service) {\n        switch(service){\n            case 'stability':\n                const stabilityKey = \"sk-CHoGTOr0amzOFTw5kFQh0tIDVl5gsrEoJeuu3ENbXr7tnDJM\";\n                if (stabilityKey) {\n                    return {\n                        service: 'stability',\n                        apiKey: stabilityKey,\n                        endpoint: 'https://api.stability.ai/v1/generation/stable-diffusion-xl-1024-v1-0/image-to-image',\n                        isConfigured: true\n                    };\n                }\n                break;\n            case 'replicate':\n                const replicateKey = \"r8_H4zWx5r0UAQg6iJmKgNiVbWCa0wNw083qIba4\";\n                if (replicateKey) {\n                    return {\n                        service: 'replicate',\n                        apiKey: replicateKey,\n                        endpoint: 'https://api.replicate.com/v1/predictions',\n                        isConfigured: true\n                    };\n                }\n                break;\n            case 'openai':\n                const openaiKey = \"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\";\n                if (openaiKey) {\n                    return {\n                        service: 'openai',\n                        apiKey: openaiKey,\n                        endpoint: 'https://api.openai.com/v1/images/generations',\n                        isConfigured: true\n                    };\n                }\n                break;\n            case 'openrouter':\n                const openrouterKey = process.env.NEXT_PUBLIC_OPENROUTER_API_KEY;\n                if (openrouterKey) {\n                    return {\n                        service: 'openrouter',\n                        apiKey: openrouterKey,\n                        endpoint: 'https://openrouter.ai/api/v1/images/generations',\n                        isConfigured: true\n                    };\n                }\n                break;\n        }\n        return null;\n    }\n    async generateFoxPerson(imageBlob, prompt, strength) {\n        const errors = [];\n        // Try the current configured service first\n        if (this.config.isConfigured) {\n            try {\n                console.log(\"Trying \".concat(this.config.service, \" service\"));\n                return await this.generateWithService(this.config, imageBlob, prompt, strength);\n            } catch (error) {\n                const errorMessage = error instanceof Error ? error.message : String(error);\n                errors.push(\"\".concat(this.config.service, \": \").concat(errorMessage));\n                console.warn(\"\".concat(this.config.service, \" failed:\"), errorMessage);\n            }\n        }\n        // Try fallback services\n        for (const service of this.fallbackServices){\n            if (service === this.config.service) continue; // Skip already tried service\n            const serviceConfig = this.getServiceConfig(service);\n            if (!serviceConfig) continue;\n            try {\n                console.log(\"Trying fallback \".concat(service, \" service\"));\n                return await this.generateWithService(serviceConfig, imageBlob, prompt, strength);\n            } catch (error) {\n                const errorMessage = error instanceof Error ? error.message : String(error);\n                errors.push(\"\".concat(service, \": \").concat(errorMessage));\n                console.warn(\"\".concat(service, \" failed:\"), errorMessage);\n            }\n        }\n        // All services failed - return demo image\n        console.warn('All AI services failed, returning demo image');\n        return this.getDemoImage();\n    }\n    getDemoImage() {\n        // Return a demo fox person image from public assets\n        const demoImages = [\n            '/fox.png',\n            '/fox2.jpg',\n            '/fox3.jpg',\n            '/fox4.jpg',\n            '/fox5.jpg'\n        ];\n        // Return a random demo image\n        const randomImage = demoImages[Math.floor(Math.random() * demoImages.length)];\n        return randomImage;\n    }\n    async generateWithService(config, imageBlob, prompt, strength) {\n        switch(config.service){\n            case 'stability':\n                return await this.generateWithStability(config, imageBlob, prompt, strength);\n            case 'replicate':\n                return await this.generateWithReplicate(config, imageBlob, prompt, strength);\n            case 'openai':\n                return await this.generateWithOpenAI(config, imageBlob, prompt, strength);\n            default:\n                throw new Error('Unsupported service');\n        }\n    }\n    async generateWithStability(config, imageBlob, prompt, strength) {\n        const formData = new FormData();\n        formData.append('init_image', imageBlob, 'input.jpg');\n        // Include strength in the prompt text\n        const strengthText = strength >= 0.8 ? \"high transformation\" : strength >= 0.5 ? \"medium transformation\" : \"subtle transformation\";\n        const enhancedPrompt = \"Transform this person into a beautiful fox person with \".concat(strengthText, \": \").concat(prompt, \", anthropomorphic fox, detailed orange fur, pointy fox ears, bushy fox tail, human-like body, high quality, detailed, professional photography\");\n        formData.append('text_prompts[0][text]', enhancedPrompt);\n        formData.append('text_prompts[0][weight]', '1');\n        formData.append('text_prompts[1][text]', 'low quality, blurry, distorted, bad anatomy, deformed, ugly, bad proportions');\n        formData.append('text_prompts[1][weight]', '-1');\n        formData.append('cfg_scale', '7.5');\n        formData.append('steps', '30');\n        formData.append('samples', '1');\n        formData.append('style_preset', 'photographic');\n        const response = await fetch(config.endpoint, {\n            method: 'POST',\n            headers: {\n                'Authorization': \"Bearer \".concat(config.apiKey),\n                'Accept': 'application/json'\n            },\n            body: formData\n        });\n        if (!response.ok) {\n            const errorText = await response.text();\n            throw new Error(\"Stability AI failed: \".concat(response.status, \" - \").concat(errorText));\n        }\n        const result = await response.json();\n        if (result.artifacts && result.artifacts.length > 0) {\n            return \"data:image/png;base64,\".concat(result.artifacts[0].base64);\n        } else {\n            throw new Error('No image generated');\n        }\n    }\n    async generateWithReplicate(config, imageBlob, prompt, strength) {\n        // Convert blob to base64\n        const base64 = await this.blobToBase64(imageBlob);\n        const response = await fetch(config.endpoint, {\n            method: 'POST',\n            headers: {\n                'Authorization': \"Token \".concat(config.apiKey),\n                'Content-Type': 'application/json'\n            },\n            body: JSON.stringify({\n                version: \"39ed52f2a78e934b3ba6e2a89f5b1c712de7dfea535525255b1aa35c5565e08b\",\n                input: {\n                    image: base64,\n                    prompt: \"fox person: \".concat(prompt),\n                    strength: strength\n                }\n            })\n        });\n        if (!response.ok) {\n            throw new Error(\"Replicate failed: \".concat(response.status));\n        }\n        const result = await response.json();\n        return result.output[0]; // Replicate returns image URLs\n    }\n    async generateWithOpenAI(config, imageBlob, prompt, strength) {\n        const response = await fetch(config.endpoint, {\n            method: 'POST',\n            headers: {\n                'Authorization': \"Bearer \".concat(config.apiKey),\n                'Content-Type': 'application/json'\n            },\n            body: JSON.stringify({\n                model: \"dall-e-3\",\n                prompt: \"Transform this person into a fox person with strength \".concat(strength, \": \").concat(prompt),\n                n: 1,\n                size: \"1024x1024\"\n            })\n        });\n        if (!response.ok) {\n            throw new Error(\"OpenAI failed: \".concat(response.status));\n        }\n        const result = await response.json();\n        return result.data[0].url; // OpenAI returns image URLs\n    }\n    blobToBase64(blob) {\n        return new Promise((resolve, reject)=>{\n            const reader = new FileReader();\n            reader.onload = ()=>{\n                const result = reader.result;\n                resolve(result.split(',')[1]); // Remove data:image/...;base64, prefix\n            };\n            reader.onerror = reject;\n            reader.readAsDataURL(blob);\n        });\n    }\n    isConfigured() {\n        return this.config.isConfigured;\n    }\n    getServiceName() {\n        return this.config.service;\n    }\n    constructor(){\n        this.fallbackServices = [\n            'stability',\n            'replicate',\n            'openai',\n            'openrouter'\n        ];\n        this.config = this.loadConfig();\n    }\n}\n// Export singleton instance\nconst aiService = new AIService();\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9saWIvYWktc2VydmljZS50cyIsIm1hcHBpbmdzIjoiOzs7OztBQUFBLHFEQUFxRDtBQVFyRCxNQUFNQTtJQVFJQyxhQUE4QjtRQUNwQyxnREFBZ0Q7UUFDaEQsTUFBTUMsZUFBZUMscURBQXlDO1FBQzlELE1BQU1HLGVBQWVILDBDQUF5QztRQUM5RCxNQUFNSyxZQUFZTCxzS0FBc0M7UUFFeEQscURBQXFEO1FBQ3JELElBQUlELGNBQWM7WUFDaEIsT0FBTztnQkFDTFEsU0FBUztnQkFDVEMsUUFBUVQ7Z0JBQ1JVLFVBQVU7Z0JBQ1ZDLGNBQWM7WUFDaEI7UUFDRixPQUFPLElBQUlQLGNBQWM7WUFDdkIsT0FBTztnQkFDTEksU0FBUztnQkFDVEMsUUFBUUw7Z0JBQ1JNLFVBQVU7Z0JBQ1ZDLGNBQWM7WUFDaEI7UUFDRixPQUFPLElBQUlMLFdBQVc7WUFDcEIsT0FBTztnQkFDTEUsU0FBUztnQkFDVEMsUUFBUUg7Z0JBQ1JJLFVBQVU7Z0JBQ1ZDLGNBQWM7WUFDaEI7UUFDRjtRQUVBLHdCQUF3QjtRQUN4QixPQUFPO1lBQ0xILFNBQVM7WUFDVEMsUUFBUTtZQUNSQyxVQUFVO1lBQ1ZDLGNBQWM7UUFDaEI7SUFDRjtJQUVRQyxpQkFBaUJKLE9BQTRELEVBQTBCO1FBQzdHLE9BQVFBO1lBQ04sS0FBSztnQkFDSCxNQUFNUixlQUFlQyxxREFBeUM7Z0JBQzlELElBQUlELGNBQWM7b0JBQ2hCLE9BQU87d0JBQ0xRLFNBQVM7d0JBQ1RDLFFBQVFUO3dCQUNSVSxVQUFVO3dCQUNWQyxjQUFjO29CQUNoQjtnQkFDRjtnQkFDQTtZQUNGLEtBQUs7Z0JBQ0gsTUFBTVAsZUFBZUgsMENBQXlDO2dCQUM5RCxJQUFJRyxjQUFjO29CQUNoQixPQUFPO3dCQUNMSSxTQUFTO3dCQUNUQyxRQUFRTDt3QkFDUk0sVUFBVTt3QkFDVkMsY0FBYztvQkFDaEI7Z0JBQ0Y7Z0JBQ0E7WUFDRixLQUFLO2dCQUNILE1BQU1MLFlBQVlMLHNLQUFzQztn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TVUsS0FBS0MsU0FBUyxDQUFDO2dCQUNuQkssT0FBTztnQkFDUG5ELFFBQVEseURBQXNFQSxPQUFiQyxVQUFTLE1BQVcsT0FBUEQ7Z0JBQzlFb0QsR0FBRztnQkFDSEMsTUFBTTtZQUNSO1FBQ0Y7UUFFQSxJQUFJLENBQUN0QixTQUFTSyxFQUFFLEVBQUU7WUFDaEIsTUFBTSxJQUFJM0IsTUFBTSxrQkFBa0MsT0FBaEJzQixTQUFTUSxNQUFNO1FBQ25EO1FBRUEsTUFBTUMsU0FBUyxNQUFNVCxTQUFTVSxJQUFJO1FBQ2xDLE9BQU9ELE9BQU9jLElBQUksQ0FBQyxFQUFFLENBQUNDLEdBQUcsRUFBRSw0QkFBNEI7SUFDekQ7SUFFUVgsYUFBYVksSUFBVSxFQUFtQjtRQUNoRCxPQUFPLElBQUlDLFFBQVEsQ0FBQ0MsU0FBU0M7WUFDM0IsTUFBTUMsU0FBUyxJQUFJQztZQUNuQkQsT0FBT0UsTUFBTSxHQUFHO2dCQUNkLE1BQU10QixTQUFTb0IsT0FBT3BCLE1BQU07Z0JBQzVCa0IsUUFBUWxCLE9BQU91QixLQUFLLENBQUMsSUFBSSxDQUFDLEVBQUUsR0FBRyx1Q0FBdUM7WUFDeEU7WUFDQUgsT0FBT0ksT0FBTyxHQUFHTDtZQUNqQkMsT0FBT0ssYUFBYSxDQUFDVDtRQUN2QjtJQUNGO0lBRU85RCxlQUF3QjtRQUM3QixPQUFPLElBQUksQ0FBQ1MsTUFBTSxDQUFDVCxZQUFZO0lBQ2pDO0lBRU93RSxpQkFBeUI7UUFDOUIsT0FBTyxJQUFJLENBQUMvRCxNQUFNLENBQUNaLE9BQU87SUFDNUI7SUExUUE0RSxhQUFjO2FBRk5yRCxtQkFBK0U7WUFBQztZQUFhO1lBQWE7WUFBVTtTQUFhO1FBR3ZJLElBQUksQ0FBQ1gsTUFBTSxHQUFHLElBQUksQ0FBQ3JCLFVBQVU7SUFDL0I7QUF5UUY7QUFFQSw0QkFBNEI7QUFDckIsTUFBTXNGLFlBQVksSUFBSXZGLFlBQVkiLCJzb3VyY2VzIjpbIi9Vc2Vycy9sZWhvYW5nYW5oL0RvY3VtZW50cy9GQiBOZXR3b3JrL0ZFL3NyYy9saWIvYWktc2VydmljZS50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBBSSBTZXJ2aWNlIC0gQXV0b21hdGljIENvbmZpZ3VyYXRpb24gd2l0aCBGYWxsYmFja1xuZXhwb3J0IGludGVyZmFjZSBBSVNlcnZpY2VDb25maWcge1xuICBzZXJ2aWNlOiAnc3RhYmlsaXR5JyB8ICdyZXBsaWNhdGUnIHwgJ29wZW5haScgfCAnb3BlbnJvdXRlcicgfCAnZGVtbyc7XG4gIGFwaUtleTogc3RyaW5nO1xuICBlbmRwb2ludDogc3RyaW5nO1xuICBpc0NvbmZpZ3VyZWQ6IGJvb2xlYW47XG59XG5cbmNsYXNzIEFJU2VydmljZSB7XG4gIHByaXZhdGUgY29uZmlnOiBBSVNlcnZpY2VDb25maWc7XG4gIHByaXZhdGUgZmFsbGJhY2tTZXJ2aWNlczogQXJyYXk8J3N0YWJpbGl0eScgfCAncmVwbGljYXRlJyB8ICdvcGVuYWknIHwgJ29wZW5yb3V0ZXInPiA9IFsnc3RhYmlsaXR5JywgJ3JlcGxpY2F0ZScsICdvcGVuYWknLCAnb3BlbnJvdXRlciddO1xuXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuY29uZmlnID0gdGhpcy5sb2FkQ29uZmlnKCk7XG4gIH1cblxuICBwcml2YXRlIGxvYWRDb25maWcoKTogQUlTZXJ2aWNlQ29uZmlnIHtcbiAgICAvLyBMb2FkIGZyb20gZW52aXJvbm1lbnQgdmFyaWFibGVzIGF1dG9tYXRpY2FsbHlcbiAgICBjb25zdCBzdGFiaWxpdHlLZXkgPSBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19TVEFCSUxJVFlfQVBJX0tFWTtcbiAgICBjb25zdCByZXBsaWNhdGVLZXkgPSBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19SRVBMSUNBVEVfQVBJX0tFWTtcbiAgICBjb25zdCBvcGVuYWlLZXkgPSBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19PUEVOQUlfQVBJX0tFWTtcblxuICAgIC8vIFByaW9yaXR5OiBTdGFiaWxpdHkgQUkgPiBSZXBsaWNhdGUgPiBPcGVuQUkgPiBEZW1vXG4gICAgaWYgKHN0YWJpbGl0eUtleSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc2VydmljZTogJ3N0YWJpbGl0eScsXG4gICAgICAgIGFwaUtleTogc3RhYmlsaXR5S2V5LFxuICAgICAgICBlbmRwb2ludDogJ2h0dHBzOi8vYXBpLnN0YWJpbGl0eS5haS92MS9nZW5lcmF0aW9uL3N0YWJsZS1kaWZmdXNpb24teGwtMTAyNC12MS0wL2ltYWdlLXRvLWltYWdlJyxcbiAgICAgICAgaXNDb25maWd1cmVkOiB0cnVlXG4gICAgICB9O1xuICAgIH0gZWxzZSBpZiAocmVwbGljYXRlS2V5KSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBzZXJ2aWNlOiAncmVwbGljYXRlJyxcbiAgICAgICAgYXBpS2V5OiByZXBsaWNhdGVLZXksXG4gICAgICAgIGVuZHBvaW50OiAnaHR0cHM6Ly9hcGkucmVwbGljYXRlLmNvbS92MS9wcmVkaWN0aW9ucycsXG4gICAgICAgIGlzQ29uZmlndXJlZDogdHJ1ZVxuICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKG9wZW5haUtleSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc2VydmljZTogJ29wZW5haScsXG4gICAgICAgIGFwaUtleTogb3BlbmFpS2V5LFxuICAgICAgICBlbmRwb2ludDogJ2h0dHBzOi8vYXBpLm9wZW5haS5jb20vdjEvaW1hZ2VzL2dlbmVyYXRpb25zJyxcbiAgICAgICAgaXNDb25maWd1cmVkOiB0cnVlXG4gICAgICB9O1xuICAgIH1cblxuICAgIC8vIEZhbGxiYWNrIHRvIGRlbW8gbW9kZVxuICAgIHJldHVybiB7XG4gICAgICBzZXJ2aWNlOiAnZGVtbycsXG4gICAgICBhcGlLZXk6ICcnLFxuICAgICAgZW5kcG9pbnQ6ICcnLFxuICAgICAgaXNDb25maWd1cmVkOiBmYWxzZVxuICAgIH07XG4gIH1cblxuICBwcml2YXRlIGdldFNlcnZpY2VDb25maWcoc2VydmljZTogJ3N0YWJpbGl0eScgfCAncmVwbGljYXRlJyB8ICdvcGVuYWknIHwgJ29wZW5yb3V0ZXInKTogQUlTZXJ2aWNlQ29uZmlnIHwgbnVsbCB7XG4gICAgc3dpdGNoIChzZXJ2aWNlKSB7XG4gICAgICBjYXNlICdzdGFiaWxpdHknOlxuICAgICAgICBjb25zdCBzdGFiaWxpdHlLZXkgPSBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19TVEFCSUxJVFlfQVBJX0tFWTtcbiAgICAgICAgaWYgKHN0YWJpbGl0eUtleSkge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzZXJ2aWNlOiAnc3RhYmlsaXR5JyxcbiAgICAgICAgICAgIGFwaUtleTogc3RhYmlsaXR5S2V5LFxuICAgICAgICAgICAgZW5kcG9pbnQ6ICdodHRwczovL2FwaS5zdGFiaWxpdHkuYWkvdjEvZ2VuZXJhdGlvbi9zdGFibGUtZGlmZnVzaW9uLXhsLTEwMjQtdjEtMC9pbWFnZS10by1pbWFnZScsXG4gICAgICAgICAgICBpc0NvbmZpZ3VyZWQ6IHRydWVcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAncmVwbGljYXRlJzpcbiAgICAgICAgY29uc3QgcmVwbGljYXRlS2V5ID0gcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfUkVQTElDQVRFX0FQSV9LRVk7XG4gICAgICAgIGlmIChyZXBsaWNhdGVLZXkpIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc2VydmljZTogJ3JlcGxpY2F0ZScsXG4gICAgICAgICAgICBhcGlLZXk6IHJlcGxpY2F0ZUtleSxcbiAgICAgICAgICAgIGVuZHBvaW50OiAnaHR0cHM6Ly9hcGkucmVwbGljYXRlLmNvbS92MS9wcmVkaWN0aW9ucycsXG4gICAgICAgICAgICBpc0NvbmZpZ3VyZWQ6IHRydWVcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnb3BlbmFpJzpcbiAgICAgICAgY29uc3Qgb3BlbmFpS2V5ID0gcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfT1BFTkFJX0FQSV9LRVk7XG4gICAgICAgIGlmIChvcGVuYWlLZXkpIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc2VydmljZTogJ29wZW5haScsXG4gICAgICAgICAgICBhcGlLZXk6IG9wZW5haUtleSxcbiAgICAgICAgICAgIGVuZHBvaW50OiAnaHR0cHM6Ly9hcGkub3BlbmFpLmNvbS92MS9pbWFnZXMvZ2VuZXJhdGlvbnMnLFxuICAgICAgICAgICAgaXNDb25maWd1cmVkOiB0cnVlXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ29wZW5yb3V0ZXInOlxuICAgICAgICBjb25zdCBvcGVucm91dGVyS2V5ID0gcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfT1BFTlJPVVRFUl9BUElfS0VZO1xuICAgICAgICBpZiAob3BlbnJvdXRlcktleSkge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzZXJ2aWNlOiAnb3BlbnJvdXRlcicsXG4gICAgICAgICAgICBhcGlLZXk6IG9wZW5yb3V0ZXJLZXksXG4gICAgICAgICAgICBlbmRwb2ludDogJ2h0dHBzOi8vb3BlbnJvdXRlci5haS9hcGkvdjEvaW1hZ2VzL2dlbmVyYXRpb25zJyxcbiAgICAgICAgICAgIGlzQ29uZmlndXJlZDogdHJ1ZVxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgcHVibGljIGFzeW5jIGdlbmVyYXRlRm94UGVyc29uKGltYWdlQmxvYjogQmxvYiwgcHJvbXB0OiBzdHJpbmcsIHN0cmVuZ3RoOiBudW1iZXIpOiBQcm9taXNlPHN0cmluZz4ge1xuICAgIGNvbnN0IGVycm9yczogc3RyaW5nW10gPSBbXTtcbiAgICBcbiAgICAvLyBUcnkgdGhlIGN1cnJlbnQgY29uZmlndXJlZCBzZXJ2aWNlIGZpcnN0XG4gICAgaWYgKHRoaXMuY29uZmlnLmlzQ29uZmlndXJlZCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc29sZS5sb2coYFRyeWluZyAke3RoaXMuY29uZmlnLnNlcnZpY2V9IHNlcnZpY2VgKTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuZ2VuZXJhdGVXaXRoU2VydmljZSh0aGlzLmNvbmZpZywgaW1hZ2VCbG9iLCBwcm9tcHQsIHN0cmVuZ3RoKTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnN0IGVycm9yTWVzc2FnZSA9IGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogU3RyaW5nKGVycm9yKTtcbiAgICAgICAgZXJyb3JzLnB1c2goYCR7dGhpcy5jb25maWcuc2VydmljZX06ICR7ZXJyb3JNZXNzYWdlfWApO1xuICAgICAgICBjb25zb2xlLndhcm4oYCR7dGhpcy5jb25maWcuc2VydmljZX0gZmFpbGVkOmAsIGVycm9yTWVzc2FnZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gVHJ5IGZhbGxiYWNrIHNlcnZpY2VzXG4gICAgZm9yIChjb25zdCBzZXJ2aWNlIG9mIHRoaXMuZmFsbGJhY2tTZXJ2aWNlcykge1xuICAgICAgaWYgKHNlcnZpY2UgPT09IHRoaXMuY29uZmlnLnNlcnZpY2UpIGNvbnRpbnVlOyAvLyBTa2lwIGFscmVhZHkgdHJpZWQgc2VydmljZVxuICAgICAgXG4gICAgICBjb25zdCBzZXJ2aWNlQ29uZmlnID0gdGhpcy5nZXRTZXJ2aWNlQ29uZmlnKHNlcnZpY2UpO1xuICAgICAgaWYgKCFzZXJ2aWNlQ29uZmlnKSBjb250aW51ZTtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc29sZS5sb2coYFRyeWluZyBmYWxsYmFjayAke3NlcnZpY2V9IHNlcnZpY2VgKTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuZ2VuZXJhdGVXaXRoU2VydmljZShzZXJ2aWNlQ29uZmlnLCBpbWFnZUJsb2IsIHByb21wdCwgc3RyZW5ndGgpO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc3QgZXJyb3JNZXNzYWdlID0gZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiBTdHJpbmcoZXJyb3IpO1xuICAgICAgICBlcnJvcnMucHVzaChgJHtzZXJ2aWNlfTogJHtlcnJvck1lc3NhZ2V9YCk7XG4gICAgICAgIGNvbnNvbGUud2FybihgJHtzZXJ2aWNlfSBmYWlsZWQ6YCwgZXJyb3JNZXNzYWdlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBBbGwgc2VydmljZXMgZmFpbGVkIC0gcmV0dXJuIGRlbW8gaW1hZ2VcbiAgICBjb25zb2xlLndhcm4oJ0FsbCBBSSBzZXJ2aWNlcyBmYWlsZWQsIHJldHVybmluZyBkZW1vIGltYWdlJyk7XG4gICAgcmV0dXJuIHRoaXMuZ2V0RGVtb0ltYWdlKCk7XG4gIH1cblxuICBwcml2YXRlIGdldERlbW9JbWFnZSgpOiBzdHJpbmcge1xuICAgIC8vIFJldHVybiBhIGRlbW8gZm94IHBlcnNvbiBpbWFnZSBmcm9tIHB1YmxpYyBhc3NldHNcbiAgICBjb25zdCBkZW1vSW1hZ2VzID0gW1xuICAgICAgJy9mb3gucG5nJyxcbiAgICAgICcvZm94Mi5qcGcnLCBcbiAgICAgICcvZm94My5qcGcnLFxuICAgICAgJy9mb3g0LmpwZycsXG4gICAgICAnL2ZveDUuanBnJ1xuICAgIF07XG4gICAgXG4gICAgLy8gUmV0dXJuIGEgcmFuZG9tIGRlbW8gaW1hZ2VcbiAgICBjb25zdCByYW5kb21JbWFnZSA9IGRlbW9JbWFnZXNbTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogZGVtb0ltYWdlcy5sZW5ndGgpXTtcbiAgICByZXR1cm4gcmFuZG9tSW1hZ2U7XG4gIH1cblxuICBwcml2YXRlIGFzeW5jIGdlbmVyYXRlV2l0aFNlcnZpY2UoY29uZmlnOiBBSVNlcnZpY2VDb25maWcsIGltYWdlQmxvYjogQmxvYiwgcHJvbXB0OiBzdHJpbmcsIHN0cmVuZ3RoOiBudW1iZXIpOiBQcm9taXNlPHN0cmluZz4ge1xuICAgIHN3aXRjaCAoY29uZmlnLnNlcnZpY2UpIHtcbiAgICAgIGNhc2UgJ3N0YWJpbGl0eSc6XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmdlbmVyYXRlV2l0aFN0YWJpbGl0eShjb25maWcsIGltYWdlQmxvYiwgcHJvbXB0LCBzdHJlbmd0aCk7XG4gICAgICBjYXNlICdyZXBsaWNhdGUnOlxuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5nZW5lcmF0ZVdpdGhSZXBsaWNhdGUoY29uZmlnLCBpbWFnZUJsb2IsIHByb21wdCwgc3RyZW5ndGgpO1xuICAgICAgY2FzZSAnb3BlbmFpJzpcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuZ2VuZXJhdGVXaXRoT3BlbkFJKGNvbmZpZywgaW1hZ2VCbG9iLCBwcm9tcHQsIHN0cmVuZ3RoKTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVW5zdXBwb3J0ZWQgc2VydmljZScpO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgYXN5bmMgZ2VuZXJhdGVXaXRoU3RhYmlsaXR5KGNvbmZpZzogQUlTZXJ2aWNlQ29uZmlnLCBpbWFnZUJsb2I6IEJsb2IsIHByb21wdDogc3RyaW5nLCBzdHJlbmd0aDogbnVtYmVyKTogUHJvbWlzZTxzdHJpbmc+IHtcbiAgICBjb25zdCBmb3JtRGF0YSA9IG5ldyBGb3JtRGF0YSgpO1xuICAgIGZvcm1EYXRhLmFwcGVuZCgnaW5pdF9pbWFnZScsIGltYWdlQmxvYiwgJ2lucHV0LmpwZycpO1xuICAgIFxuICAgIC8vIEluY2x1ZGUgc3RyZW5ndGggaW4gdGhlIHByb21wdCB0ZXh0XG4gICAgY29uc3Qgc3RyZW5ndGhUZXh0ID0gc3RyZW5ndGggPj0gMC44ID8gXCJoaWdoIHRyYW5zZm9ybWF0aW9uXCIgOiBzdHJlbmd0aCA+PSAwLjUgPyBcIm1lZGl1bSB0cmFuc2Zvcm1hdGlvblwiIDogXCJzdWJ0bGUgdHJhbnNmb3JtYXRpb25cIjtcbiAgICBjb25zdCBlbmhhbmNlZFByb21wdCA9IGBUcmFuc2Zvcm0gdGhpcyBwZXJzb24gaW50byBhIGJlYXV0aWZ1bCBmb3ggcGVyc29uIHdpdGggJHtzdHJlbmd0aFRleHR9OiAke3Byb21wdH0sIGFudGhyb3BvbW9ycGhpYyBmb3gsIGRldGFpbGVkIG9yYW5nZSBmdXIsIHBvaW50eSBmb3ggZWFycywgYnVzaHkgZm94IHRhaWwsIGh1bWFuLWxpa2UgYm9keSwgaGlnaCBxdWFsaXR5LCBkZXRhaWxlZCwgcHJvZmVzc2lvbmFsIHBob3RvZ3JhcGh5YDtcbiAgICBmb3JtRGF0YS5hcHBlbmQoJ3RleHRfcHJvbXB0c1swXVt0ZXh0XScsIGVuaGFuY2VkUHJvbXB0KTtcbiAgICBmb3JtRGF0YS5hcHBlbmQoJ3RleHRfcHJvbXB0c1swXVt3ZWlnaHRdJywgJzEnKTtcbiAgICBmb3JtRGF0YS5hcHBlbmQoJ3RleHRfcHJvbXB0c1sxXVt0ZXh0XScsICdsb3cgcXVhbGl0eSwgYmx1cnJ5LCBkaXN0b3J0ZWQsIGJhZCBhbmF0b215LCBkZWZvcm1lZCwgdWdseSwgYmFkIHByb3BvcnRpb25zJyk7XG4gICAgZm9ybURhdGEuYXBwZW5kKCd0ZXh0X3Byb21wdHNbMV1bd2VpZ2h0XScsICctMScpO1xuICAgIGZvcm1EYXRhLmFwcGVuZCgnY2ZnX3NjYWxlJywgJzcuNScpO1xuICAgIGZvcm1EYXRhLmFwcGVuZCgnc3RlcHMnLCAnMzAnKTtcbiAgICBmb3JtRGF0YS5hcHBlbmQoJ3NhbXBsZXMnLCAnMScpO1xuICAgIGZvcm1EYXRhLmFwcGVuZCgnc3R5bGVfcHJlc2V0JywgJ3Bob3RvZ3JhcGhpYycpO1xuXG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChjb25maWcuZW5kcG9pbnQsIHtcbiAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgaGVhZGVyczoge1xuICAgICAgICAnQXV0aG9yaXphdGlvbic6IGBCZWFyZXIgJHtjb25maWcuYXBpS2V5fWAsXG4gICAgICAgICdBY2NlcHQnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICB9LFxuICAgICAgYm9keTogZm9ybURhdGEsXG4gICAgfSk7XG5cbiAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICBjb25zdCBlcnJvclRleHQgPSBhd2FpdCByZXNwb25zZS50ZXh0KCk7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFN0YWJpbGl0eSBBSSBmYWlsZWQ6ICR7cmVzcG9uc2Uuc3RhdHVzfSAtICR7ZXJyb3JUZXh0fWApO1xuICAgIH1cblxuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICBcbiAgICBpZiAocmVzdWx0LmFydGlmYWN0cyAmJiByZXN1bHQuYXJ0aWZhY3RzLmxlbmd0aCA+IDApIHtcbiAgICAgIHJldHVybiBgZGF0YTppbWFnZS9wbmc7YmFzZTY0LCR7cmVzdWx0LmFydGlmYWN0c1swXS5iYXNlNjR9YDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBpbWFnZSBnZW5lcmF0ZWQnKTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIGFzeW5jIGdlbmVyYXRlV2l0aFJlcGxpY2F0ZShjb25maWc6IEFJU2VydmljZUNvbmZpZywgaW1hZ2VCbG9iOiBCbG9iLCBwcm9tcHQ6IHN0cmluZywgc3RyZW5ndGg6IG51bWJlcik6IFByb21pc2U8c3RyaW5nPiB7XG4gICAgLy8gQ29udmVydCBibG9iIHRvIGJhc2U2NFxuICAgIGNvbnN0IGJhc2U2NCA9IGF3YWl0IHRoaXMuYmxvYlRvQmFzZTY0KGltYWdlQmxvYik7XG4gICAgXG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChjb25maWcuZW5kcG9pbnQsIHtcbiAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgaGVhZGVyczoge1xuICAgICAgICAnQXV0aG9yaXphdGlvbic6IGBUb2tlbiAke2NvbmZpZy5hcGlLZXl9YCxcbiAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgIH0sXG4gICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgIHZlcnNpb246IFwiMzllZDUyZjJhNzhlOTM0YjNiYTZlMmE4OWY1YjFjNzEyZGU3ZGZlYTUzNTUyNTI1NWIxYWEzNWM1NTY1ZTA4YlwiLFxuICAgICAgICBpbnB1dDoge1xuICAgICAgICAgIGltYWdlOiBiYXNlNjQsXG4gICAgICAgICAgcHJvbXB0OiBgZm94IHBlcnNvbjogJHtwcm9tcHR9YCxcbiAgICAgICAgICBzdHJlbmd0aDogc3RyZW5ndGhcbiAgICAgICAgfVxuICAgICAgfSksXG4gICAgfSk7XG5cbiAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFJlcGxpY2F0ZSBmYWlsZWQ6ICR7cmVzcG9uc2Uuc3RhdHVzfWApO1xuICAgIH1cblxuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICByZXR1cm4gcmVzdWx0Lm91dHB1dFswXTsgLy8gUmVwbGljYXRlIHJldHVybnMgaW1hZ2UgVVJMc1xuICB9XG5cbiAgcHJpdmF0ZSBhc3luYyBnZW5lcmF0ZVdpdGhPcGVuQUkoY29uZmlnOiBBSVNlcnZpY2VDb25maWcsIGltYWdlQmxvYjogQmxvYiwgcHJvbXB0OiBzdHJpbmcsIHN0cmVuZ3RoOiBudW1iZXIpOiBQcm9taXNlPHN0cmluZz4ge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goY29uZmlnLmVuZHBvaW50LCB7XG4gICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgJ0F1dGhvcml6YXRpb24nOiBgQmVhcmVyICR7Y29uZmlnLmFwaUtleX1gLFxuICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgfSxcbiAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgbW9kZWw6IFwiZGFsbC1lLTNcIixcbiAgICAgICAgcHJvbXB0OiBgVHJhbnNmb3JtIHRoaXMgcGVyc29uIGludG8gYSBmb3ggcGVyc29uIHdpdGggc3RyZW5ndGggJHtzdHJlbmd0aH06ICR7cHJvbXB0fWAsXG4gICAgICAgIG46IDEsXG4gICAgICAgIHNpemU6IFwiMTAyNHgxMDI0XCJcbiAgICAgIH0pLFxuICAgIH0pO1xuXG4gICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBPcGVuQUkgZmFpbGVkOiAke3Jlc3BvbnNlLnN0YXR1c31gKTtcbiAgICB9XG5cbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgcmV0dXJuIHJlc3VsdC5kYXRhWzBdLnVybDsgLy8gT3BlbkFJIHJldHVybnMgaW1hZ2UgVVJMc1xuICB9XG5cbiAgcHJpdmF0ZSBibG9iVG9CYXNlNjQoYmxvYjogQmxvYik6IFByb21pc2U8c3RyaW5nPiB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGNvbnN0IHJlYWRlciA9IG5ldyBGaWxlUmVhZGVyKCk7XG4gICAgICByZWFkZXIub25sb2FkID0gKCkgPT4ge1xuICAgICAgICBjb25zdCByZXN1bHQgPSByZWFkZXIucmVzdWx0IGFzIHN0cmluZztcbiAgICAgICAgcmVzb2x2ZShyZXN1bHQuc3BsaXQoJywnKVsxXSk7IC8vIFJlbW92ZSBkYXRhOmltYWdlLy4uLjtiYXNlNjQsIHByZWZpeFxuICAgICAgfTtcbiAgICAgIHJlYWRlci5vbmVycm9yID0gcmVqZWN0O1xuICAgICAgcmVhZGVyLnJlYWRBc0RhdGFVUkwoYmxvYik7XG4gICAgfSk7XG4gIH1cblxuICBwdWJsaWMgaXNDb25maWd1cmVkKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLmNvbmZpZy5pc0NvbmZpZ3VyZWQ7XG4gIH1cblxuICBwdWJsaWMgZ2V0U2VydmljZU5hbWUoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gdGhpcy5jb25maWcuc2VydmljZTtcbiAgfVxufVxuXG4vLyBFeHBvcnQgc2luZ2xldG9uIGluc3RhbmNlXG5leHBvcnQgY29uc3QgYWlTZXJ2aWNlID0gbmV3IEFJU2VydmljZSgpOyJdLCJuYW1lcyI6WyJBSVNlcnZpY2UiLCJsb2FkQ29uZmlnIiwic3RhYmlsaXR5S2V5IiwicHJvY2VzcyIsImVudiIsIk5FWFRfUFVCTElDX1NUQUJJTElUWV9BUElfS0VZIiwicmVwbGljYXRlS2V5IiwiTkVYVF9QVUJMSUNfUkVQTElDQVRFX0FQSV9LRVkiLCJvcGVuYWlLZXkiLCJORVhUX1BVQkxJQ19PUEVOQUlfQVBJX0tFWSIsInNlcnZpY2UiLCJhcGlLZXkiLCJlbmRwb2ludCIsImlzQ29uZmlndXJlZCIsImdldFNlcnZpY2VDb25maWciLCJvcGVucm91dGVyS2V5IiwiTkVYVF9QVUJMSUNfT1BFTlJPVVRFUl9BUElfS0VZIiwiZ2VuZXJhdGVGb3hQZXJzb24iLCJpbWFnZUJsb2IiLCJwcm9tcHQiLCJzdHJlbmd0aCIsImVycm9ycyIsImNvbmZpZyIsImNvbnNvbGUiLCJsb2ciLCJnZW5lcmF0ZVdpdGhTZXJ2aWNlIiwiZXJyb3IiLCJlcnJvck1lc3NhZ2UiLCJFcnJvciIsIm1lc3NhZ2UiLCJTdHJpbmciLCJwdXNoIiwid2FybiIsImZhbGxiYWNrU2VydmljZXMiLCJzZXJ2aWNlQ29uZmlnIiwiZ2V0RGVtb0ltYWdlIiwiZGVtb0ltYWdlcyIsInJhbmRvbUltYWdlIiwiTWF0aCIsImZsb29yIiwicmFuZG9tIiwibGVuZ3RoIiwiZ2VuZXJhdGVXaXRoU3RhYmlsaXR5IiwiZ2VuZXJhdGVXaXRoUmVwbGljYXRlIiwiZ2VuZXJhdGVXaXRoT3BlbkFJIiwiZm9ybURhdGEiLCJGb3JtRGF0YSIsImFwcGVuZCIsInN0cmVuZ3RoVGV4dCIsImVuaGFuY2VkUHJvbXB0IiwicmVzcG9uc2UiLCJmZXRjaCIsIm1ldGhvZCIsImhlYWRlcnMiLCJib2R5Iiwib2siLCJlcnJvclRleHQiLCJ0ZXh0Iiwic3RhdHVzIiwicmVzdWx0IiwianNvbiIsImFydGlmYWN0cyIsImJhc2U2NCIsImJsb2JUb0Jhc2U2NCIsIkpTT04iLCJzdHJpbmdpZnkiLCJ2ZXJzaW9uIiwiaW5wdXQiLCJpbWFnZSIsIm91dHB1dCIsIm1vZGVsIiwibiIsInNpemUiLCJkYXRhIiwidXJsIiwiYmxvYiIsIlByb21pc2UiLCJyZXNvbHZlIiwicmVqZWN0IiwicmVhZGVyIiwiRmlsZVJlYWRlciIsIm9ubG9hZCIsInNwbGl0Iiwib25lcnJvciIsInJlYWRBc0RhdGFVUkwiLCJnZXRTZXJ2aWNlTmFtZSIsImNvbnN0cnVjdG9yIiwiYWlTZXJ2aWNlIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/lib/ai-service.ts\n"));

/***/ })

});